Architektury Výpočetních Systémů (AVS 2023)
Projekt č. 2 (PMC)
Login: xsovam00

Úloha 1: Paralelizace původního řešení
===============================================================================

1) Kterou ze smyček (viz zadání) je vhodnější paralelizovat a co způsobuje 
   neefektivitu paralelizaci té druhé?

Je vhodnější paralelizovat smyčku v 'marchCubes'. Ve druhé smyčce dochází k neustálému vytváření a slučování (fork/join) vláken, což způsobuje zbytečnou režii navíc.


2) Jaké plánování (rozdělení práce mezi vlákna) jste zvolili a proč? 
   Jaký vliv má velikost "chunk" při dynamickém plánování (8, 16, 32, 64)?

schedule(guided) - nejlepší výsledky.


3) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?

Vlákna nikdy současně neukládají trojúhelníky díky '#pragma omp critical' -> jen jedno vlákno může současně ukládat, ostatní čekají.


Úloha 2: Paralelní průchod stromem
===============================================================================

1) Stručně popište použití OpenMP tasků ve vašem řešení.

Tasky se větví/vytvářejí při rozdělení kostky na 8 částí (a zavolání funkce 'octree'), pokud není překročen "cut-off", tak se větví dál. Na "cut-off" hloubce se zavolá buildCube a vrátí se počet vygenerovaných polygonů. Všechny vlákna pak čekají na vygenerování polygonů na nejnižší úrovni.


2) Jaký vliv má na vaše řešení tzv. "cut-off"? Je vhodné vytvářet nový 
   task pro každou krychli na nejnižší úrovni?

Při zvětšení cut-off se zlepšil výpočet pro 36 jader ale zhoršil se výpočet pro 18 jader. ->
Záleží na počtu jader.

Není vhodné vytvářet nový task na nejnižší úrovni, tasky se generují při rozdělení kostky (a zavolání funkce 'octree').

3) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?

Vlákna nikdy současně neukládají trojúhelníky díky '#pragma omp critical' -> jen jedno vlákno může současně ukládat, ostatní čekají.


Úloha 3: Grafy škálování všech řešení
===============================================================================

1) Stručně zhodnoťte efektivitu vytvořených řešení (na základě grafů ŠKÁLOVÁNÍ).

Efektivnější je octree. Obě řešení se škálují s počtem elementů. 
Strong scaling verzie octree je výrazne viac závislý na veľkosti vstupu.
Octree je efektívnejší pri menšom počte jadier, avšak po dosiahnutí ôsmich
jadier začína byť efektívnejšia loop verzia.


2) V jakém případě (v závislosti na počtu bodů ve vstupním souboru a velikosti 
   mřížky) bude vaše řešení 1. úlohy neefektivní? (pokud takový případ existuje)

Při malém počtu bodů mude řešení méně efektivní.


3) Je (nebo není) stromový algoritmus efektivnější z pohledu slabého škálování 
   vzhledem ke vstupu?

Při malém vstupu (Input size per thread = 10) a vlekém počtu jader (2^5) je efektivnější 'loop' implementace, jinak je efektivnější 'octree' implementace. 


4) Jaký je rozdíl mezi silným a slabým škálováním?




Úloha 4: Analýza využití jader pomocí VTune
================================================================================

1) Jaké bylo průměrné využití jader pro všechny tři implementace s omezením na 
   18 vláken? Na kolik procent byly využity?
   
   ref: Effective CPU Utilization:  2.8% (0.998 out of 36 logical CPUs) -> 5.6% pro 18 vláken
   loop: Effective CPU Utilization: 48.5% (17.452 out of 36 logical CPUs) -> 97% pro 18 vláken
   tree: Effective CPU Utilization: 44.7% (16.081 out of 36 logical CPUs) -> 89.4% pro 18 vláken

2) Jaké bylo průměrné využití jader pro všechny tři implementace s využitím 
   všech jader? Na kolik procent se podařilo využít obě CPU?
   
   ref: Effective CPU Utilization:  2.8% (0.998 out of 36 logical CPUs)
   loop: Effective CPU Utilization: 91.5% (32.924 out of 36 logical CPUs)
   tree: Effective CPU Utilization: 63.8% (22.977 out of 36 logical CPUs)

3) Jaké jsou závěry z těchto měření?

loop je nejefektivnější implementací z pohledu využití jader.